func StructScan(rows *sql.Rows, data interface{}) error {
	v := reflect.ValueOf(data)
	if v.Kind() != reflect.Ptr {
		return errors.New("must pass a pointer, not a value, to StructScan destination") // @todo add new error message

	}
	v = reflect.Indirect(v)
	t := v.Type()
	cols, _ := rows.Columns()
	var m map[string]interface{}

	for rows.Next() {
		columns := make([]interface{}, len(cols))
		columnsPointer := make([]interface{}, len(cols))
		for i := range columns {
			columnsPointer[i] = &columns[i]
		}
		if err := rows.Scan(columnsPointer...); err != nil {
			return err
		}
		m = make(map[string]interface{})
		// fmt.Println(*columnsPointer[2].(*interface{}))
		for i, colName := range cols {
			val := columnsPointer[i].(*interface{})
			m[colName] = *val
		}
		list := make([]interface{}, 0)

		for i := 0; i < v.NumField(); i++ {
			field := strings.Split(t.Field(i).Tag.Get("json"), ",")[0]

			if item, ok := m[field]; ok {
				if v.Field(i).CanSet() {
					if item != nil {
						switch v.Field(i).Kind() {
						case reflect.String:
							v.Field(i).SetString(b2s(item.([]uint8)))
						case reflect.Float32, reflect.Float64:
							v.Field(i).SetFloat(item.(float64))
						case reflect.Ptr:
							if reflect.ValueOf(item).Kind() == reflect.Bool {
								itemBool := item.(bool)
								v.Field(i).Set(reflect.ValueOf(&itemBool))
							}
						case reflect.Struct:
							v.Field(i).Set(reflect.ValueOf(item))
						default:
							fmt.Println(t.Field(i).Name, ": ", v.Field(i).Kind(), " - > - ", reflect.ValueOf(item).Kind()) // @todo remove after test out the Get methods
						}
					}
				}
			}

		}
		fmt.Println("below")
		fmt.Println(list)

	}

	return nil
}